# Немного про работу с файлами, numpy и предсказаниях

## Введение / Мотивация

<!-- TODO: Попробовать нарисовать картинки? -->

Известно, что файлы в памяти представлены последовательностью байтов.
Структурно, эта последовательность может быть разной. Она может
содержать только ASCII-текст, текст с любой кодировкой, сжатый архив,
mp3, etc. При взаимодействии с файлом (например, открыть файл
текстовым редактором), операционная система не смотрит на
т.н. **расширение файла**, её интересует *побайтовое* содержание
файла.

В Unix для определения типа файла есть утилита `file`. Как она
определяет тип я точно не знаю, но могу сказать, что частично метод
основан на *"заголовке"* файла (первых байтах).

Пример работы `file` на исполняемом файле:

```
./program: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, ...
```

Шестнадцатеричное представление (первые несколько строк) с помощью
`xxd`:

```console
00000000: 7f45 4c46 0201 0100 0000 0000 0000 0000  .ELF............
00000010: 0300 3e00 0100 0000 6010 0000 0000 0000  ..>.....`.......
00000020: 4000 0000 0000 0000 c036 0000 0000 0000  @........6......
00000030: 0000 0000 4000 3800 0d00 4000 1f00 1e00  ....@.8...@.....
```

В начале видно последовательность `ELF` -- формат исполняемых файлов в
Unix[1].

Возникает вопрос: **есть какой-то паттерн для различных типов файлов,
который можно увидеть, не считая специальных симвовол в *заголовке*?**

Можно усложнить вопрос: можно ли по какому-то обобщению (*сигнатуре*)
файла предсказать его тип? Попробуем это выяснить.

Для этого нужно решить следующие задачи:

1. Написать модуль (**на Си**), который по имени файла просчитывает
   сигнатуру и возвращает её;
2. Посмотреть, как выглядят эти сигнатуры;
3. Попробовать обучить простую нейросеть.

## Причины использования Си

## Чтение файлов в память

## Как считать сигнатуру файла

## Пайплайн обучения нейросети

## Результаты и картинки

## Источники

1. https://ru.wikipedia.org/wiki/Executable_and_Linkable_Format
